#!/bin/env python

import commands
import pwd
import re
from ScarScript import ScarScript

class leftovers(ScarScript):
  """
  leftovers - a script for finding and cleaning up allocated resources on
  batch nodes

  leftovers [-h -i -k -v] [--exclude pattern] [--include pattern]
            [--type=pattern] [pattern ...]

  This script searches specified batch hosts for resources (processes, by
  default) that belong to a user other than the one(s) assigned to the node.
  Any leftover resources discovered are reported and, if desired, reclaimed.
  Resources that belong to a user w/a UID < 500 are ignored.  Options:

    --exclude
      Only report resources that do not match pattern

    -h
      Show this information, then exit

    --include
      Only report resources that match pattern

    -i
      Interactive.  Like -k, but prompts before each reclamation.

    -k
      Reclaim any discovered leftovers

    --type
      Include only types of resources that match the given pattern.
      Recognized resource types are 'epilogue', 'jobfile', 'process',
      'scratch', 'semaphore', and 'tmpfile'.

    -v
      Print version, then exit

    pattern
      Search only hosts whose names match on of the listed patterns.  By
      default, all hosts are searched.
  """

  VERSION = 1.0

  def __init__(self):

    (options, args) = \
      self.parseArgs(["--exclude:s", "--include:s", "-i", "-k", "--type:s" ])
    if len(args) == 0:
      args.append('.')
    self.ask = options.i
    self.exclude = options.exclude
    self.include = options.include
    self.kill = options.k
    self.type = 'epilogue|jobfile|process|scratch|semaphore|tmpfile'
    if options.type:
      self.type = options.type

    nodeJobs = {}
    for pat in args:
      nodeJobs.update(self.getNodeJobs(pat))
    nodes = nodeJobs.keys()
    nodes.sort()

    for node in nodes:
      jobsOnNode = []
      usersAllowedOnNode = []
      for job in nodeJobs[node]:
        if job.find('/') > 0:
          usersAllowedOnNode.append(job.split('/')[1])
          jobsOnNode.append(job.split('/')[0])
      if re.search('epilogue', self.type):
        command = "ssh %s ls -1 /tmp | 'grep ^PBS_TEMP_'" % node
        for line in self.filterOutput(command):
          pieces = re.split("[\._]", line)
          if len(pieces) < 3:
            continue
          jobId = pieces[2]
          if not jobId.isdigit() or jobId in jobsOnNode:
            continue
          print '%s: Epilogue file %s' % (node, line)
          if self.kill or (self.ask and self.verify()):
            self.do("ssh %s /bin/rm /tmp/%s" % (node, line))
      if re.search('jobfile', self.type):
        command = "ssh %s find /opt/torque | grep '/[0-9][-0-9]*\.'" % node
        for line in self.filterOutput(command):
          jobId = re.split("[-\.]", re.split('/', line)[-1])[0]
          if not jobId.isdigit() or jobId in jobsOnNode:
            continue
          print '%s: Job file %s' % (node, line)
          if self.kill or (self.ask and self.verify()):
            self.do("ssh %s /bin/rm %s" % (node, line))
      if re.search('process', self.type):
        command = "ssh %s ps wwaux | grep -v -E '^root | USER'" % node
        for line in self.filterOutput(command):
          columns = re.split("\s+", line)
          (uid, login) = self.getUidLogin(columns[0])
          if uid < 500 or login in usersAllowedOnNode:
            continue
          pid = columns[1]
          print "%s: Process %s [%s] %s %s" % \
                (node, login, uid, pid, ' '.join(columns[10:]))
          if self.kill or (self.ask and self.verify()):
            self.do("ssh %s kill -9 %s" % (node, pid))
      if re.search('scratch', self.type):
        command = "ssh %s ls -l /state/partition1" % node
        for line in self.filterOutput(command):
          pieces = re.split("\s", line)
          if len(pieces) < 3:
            continue
          (uid, login) = self.getUidLogin(pieces[2])
          if uid < 500 or login in usersAllowedOnNode:
            continue
          file = "/state/partition1/%s" % pieces[-1]
          print '%s: Scratch file %s' % (node, line)
          if self.kill or (self.ask and self.verify()):
            self.do("ssh %s /bin/rm -rf %s" % (node, file))
      if re.search('semaphore', self.type):
        command = "ssh %s ipcs -s | grep '^0'" % node
        for line in self.filterOutput(command):
          columns = re.split("\s+", line)
          (uid, login) = self.getUidLogin(columns[2])
          if uid < 500 or login in usersAllowedOnNode:
            continue
          print '%s: Semaphore %s' (node, line)
          if self.kill or (self.ask and self.verify()):
            self.do("ssh %s ipcrm -s %s" % (node, columns[1]))
      if re.search('tmpfile', self.type):
        command = "ssh %s ls -l /tmp" % node
        for line in self.filterOutput(command):
          pieces = re.split("\s", line)
          if len(pieces) < 3:
            continue
          (uid, login) = self.getUidLogin(pieces[2])
          if uid < 500 or login in usersAllowedOnNode:
            continue
          file = "/tmp/%s" % pieces[-1]
          print '%s: Temp file %s' % (node, line)
          if self.kill or (self.ask and self.verify()):
            self.do("ssh %s /bin/rm -rf %s" % (node, file))

  def filterOutput(self, command):
    result = []
    for line in commands.getoutput(command).split("\n"):
      if line == '':
        continue
      if self.include and not re.search(self.include, line):
        continue
      if self.exclude and re.search(self.exclude, line):
        continue
      result.append(line)
    return result

  def getUidLogin(self, id):
    (uid, login) = (0, id)
    try:
      if id.isdigit():
        uid = int(id)
        login = pwd.getpwuid(uid)[0]
      else:
        uid = pwd.getpwnam(id)[2]
        login = id
    except KeyError:
      pass
    return (uid, login)

  def verify(self):
    answer = raw_input('Remove(y/n)? ')
    return answer != 'n' and answer != 'N'

leftovers()
