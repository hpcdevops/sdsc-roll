#!/bin/env python

import commands
from optparse import OptionParser
import os
import os.path
import re
import sys

class Module:

  def __init__(self, path):
    self._errors = {}
    self._programs = None
    self._libraries = None
    self._path = path
    command = "module display %s 2>&1" % path
    self._text = commands.getoutput(command)
    self._variablesMod = None
    self._variablesNew = None
    Module.instances[path] = self

  def addedLibraries(self):
    if self._libraries == None:
      self._libraries = {}
      for addition in re.findall(r'(?:ap|pre)pend-path\s+LD_LIBRARY_PATH\b([^\n]*)', self._text):
        addition = addition.strip()
        if addition == '':
          self._errors['LD_LIBRARY_PATH'] = 'empty append'
          continue
        for path in addition.split(':'):
          if not os.path.isdir(path):
            self._errors[path] = 'No such path'
            continue
          for file in os.listdir(path):
            filePath = "%s/%s" % (path, file)
            if not os.access(filePath, os.R_OK) or \
               not re.match(r'^lib.*\.so(\.\d+)*$', file):
              continue
            self._libraries[file] = filePath
    return self._libraries

  def addedPrograms(self):
    if self._programs == None:
      self._programs = {}
      for addition in re.findall(r'(?:ap|pre)pend-path\s+PATH\b([^\n]*)', self._text):
        addition = addition.strip()
        if addition == '':
          self._errors['PATH'] = 'empty append'
          continue
        for path in addition.split(':'):
          if not os.path.isdir(path):
            self._errors[path] = 'No such path'
            continue
          for file in os.listdir(path):
            filePath = "%s/%s" % (path, file)
            if not os.access(filePath, os.X_OK):
              continue
            self._programs[file] = filePath
    return self._programs

  def addedVariables(self):
    if self._variablesNew == None:
      self._variablesNew = {}
      for (var, value) in re.findall(r'setenv\s+(\S+)([^\n]*)', self._text):
        if var == 'LD_LIBRARY_PATH' or var == 'PATH':
          # handled by addedLibraries/addedPrograms
          continue
        self._variablesNew[var] = value.strip()
    return self._variablesNew

  def errors(self):
    self.addedPrograms()
    self.addedLibraries()
    self.addedVariables()
    self.modifiedVariables()
    return self._errors

  def modifiedVariables(self):
    if self._variablesMod == None:
      self._variablesMod = {}
      for (var, value) in re.findall(r'(?:ap|pre)pend-path\s+(\S+)([^\n]*)', self._text):
        value = value.strip()
        if value == '':
          self._errors[var] = 'empty append'
          continue
        if var == 'LD_LIBRARY_PATH' or var == 'PATH':
          # handled by addedLibraries/addedPrograms
          continue
        self._variablesMod[var] = value
    return self._variablesMod

  def path(self):
    return self._path

  @classmethod
  def findLibrary(cls, resource):
    result = []
    for m in Module.instances.values():
      if m.addedLibraries().has_key(resource):
        result.append(m)
    return result

  @classmethod
  def findProgram(cls, resource):
    result = []
    for m in Module.instances.values():
      if m.addedPrograms().has_key(resource):
        result.append(m)
    return result

  @classmethod
  def findVariable(cls, resource):
    result = []
    for m in Module.instances.values():
      if m.addedVariables().has_key(resource):
        result.append(m)
    return result

  @classmethod
  def initAll(cls):
    for dir in os.environ['MODULEPATH'].split(':'):
      if not os.path.exists(dir):
        continue
      for subdir in os.listdir(dir):
        subdirPath = "%s/%s" % (dir, subdir)
        if not os.path.isdir(subdirPath):
          continue
        for file in os.listdir(subdirPath):
          filePath = "%s/%s" % (subdirPath, file)
          if os.path.isdir(filePath) or file.startswith('.'):
            continue
          m = Module("%s/%s" % (subdir, file))

Module.instances = {}

class ModuleInspect:
  """
  module-inspect - report resources provided by environment modules

  module-inspect [-h -v] [--errs=y/n] [--find=resource[,resource...]]
                 [--libs=y/n] [--progs=y/n] [--vars=y/n] [module ...]

    -h
      Show this information, then exit.

    -v
      Print version, then exit.

    --find=resource[,resource...]
      Report which, if any, of the listed modulefiles supplies the listed
      resource(s).  If this option is not specified, the program reports
      all resources provided by all the listed modules.

    --errs=y/n
    --libs=y/n
    --progs=y/n
    --vars=y/n
      Specify which resources to report--modulefile errors (e.g., references
      to non-existent directories), dynamic libraries, executable programs,
      and/or environment variables.  By default the program reports all of
      these; if one or more of these options is given explicitly, the others
      are not reported.

    module ...
      List of modules to report.  By default, the program reports all
      available modules.
  """

  def __init__(self):
    """Class constructor."""

    parser = OptionParser('usage: %prog [options] [module ...]', add_help_option=False, version='%prog v0.1')
    parser.add_option('-h', '--help', action='store_true')
    parser.add_option('--errs', default='n')
    parser.add_option('--find')
    parser.add_option('--libs', default='n')
    parser.add_option('--progs', default='n')
    parser.add_option('--vars', default='n')

    (options, args) = parser.parse_args()

    if options.help:
      help(self.__class__)
      sys.exit(0)

    if options.errs == 'n' and options.libs == 'n' and \
       options.progs == 'n' and options.vars == 'n':
      options.errs = 'y'
      options.libs = 'y'
      options.progs = 'y'
      options.vars = 'y'

    if len(args) == 0:
      Module.initAll()
    else:
      for m in args:
        Module(m)

    if options.find == None:
      for path in sorted(Module.instances.keys()):
        module = Module.instances[path]
        print path
        if options.progs != 'n':
          programs = module.addedPrograms()
          for program in sorted(programs.keys()):
            print "  program %s = %s" % (program, programs[program])
        if options.libs != 'n':
          libraries = module.addedLibraries()
          for library in sorted(libraries.keys()):
            print "  library %s = %s" % (library, libraries[library])
        if options.vars != 'n':
          variables = module.addedVariables()
          for variable in sorted(variables.keys()):
            print "  variable %s = %s" % (variable, variables[variable])
          variables = module.modifiedVariables()
          for variable in sorted(variables.keys()):
            print "  variable %s += %s" % (variable, variables[variable])
        if options.errs != 'n':
          errors = module.errors()
          for error in sorted(errors.keys()):
            print "  error %s = %s" % (error, errors[error])
    else:
      for resource in options.find.split(','):
        if options.progs != 'n':
          for module in Module.findProgram(resource):
            print "program %s provided by %s" % (resource, module.path())
        if options.libs != 'n':
          for module in Module.findLibrary(resource):
            print "library %s provided by %s" % (resource, module.path())
        if options.vars != 'n':
          for module in Module.findVariable(resource):
            print "variable %s provided by %s" % (resource, module.path())

ModuleInspect()
